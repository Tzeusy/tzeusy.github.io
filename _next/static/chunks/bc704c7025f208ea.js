(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["object"==typeof document?document.currentScript:void 0,94909,(e,t,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0});var i={default:function(){return h},getImageProps:function(){return u}};for(var n in i)Object.defineProperty(r,n,{enumerable:!0,get:i[n]});let o=e.r(55682),d=e.r(8927),a=e.r(5500),s=o._(e.r(1948));function u(e){let{props:t}=(0,d.getImgProps)(e,{defaultLoader:s.default,imgConf:{deviceSizes:[640,750,828,1080,1200,1920,2048,3840],imageSizes:[32,48,64,96,128,256,384],qualities:[75],path:"/_next/image",loader:"default",dangerouslyAllowSVG:!1,unoptimized:!0}});for(let[e,r]of Object.entries(t))void 0===r&&delete t[e];return{props:t}}let h=a.Image},57688,(e,t,r)=>{t.exports=e.r(94909)},85169,e=>{"use strict";let t;var r=e.i(43476),i=e.i(71645),n=e.i(57688),o=e.i(18566),d=e.i(19298);let a=function(){let e=arguments[0];for(let t=1,r=arguments.length;t<r;t++)if(arguments[t])for(let r in arguments[t])e[r]=arguments[t][r];return e};function s(e,t,r,i){let n=e._nodes.get(t),o=null;return n?o="mixed"===i?n.out&&n.out[r]||n.undirected&&n.undirected[r]:"directed"===i?n.out&&n.out[r]:n.undirected&&n.undirected[r]:o}function u(e){return"object"==typeof e&&null!==e}function h(e){let t;for(t in e)return!1;return!0}function l(e,t,r){Object.defineProperty(e,t,{enumerable:!1,configurable:!1,writable:!0,value:r})}function c(e,t,r){let i={enumerable:!0,configurable:!0};"function"==typeof r?i.get=r:(i.value=r,i.writable=!1),Object.defineProperty(e,t,i)}function p(e){return!!u(e)&&(!e.attributes||!!Array.isArray(e.attributes))}function g(){let e=arguments,t=null,r=-1;return{[Symbol.iterator](){return this},next(){let i=null;for(;;){if(null===t){if(++r>=e.length)return{done:!0};t=e[r][Symbol.iterator]()}if((i=t.next()).done){t=null;continue}break}return i}}}function f(){return{[Symbol.iterator](){return this},next:()=>({done:!0})}}"function"==typeof Object.assign&&(a=Object.assign);class y extends Error{constructor(e){super(),this.name="GraphError",this.message=e}}class m extends y{constructor(e){super(e),this.name="InvalidArgumentsGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,m.prototype.constructor)}}class b extends y{constructor(e){super(e),this.name="NotFoundGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,b.prototype.constructor)}}class w extends y{constructor(e){super(e),this.name="UsageGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,w.prototype.constructor)}}function x(e,t){this.key=e,this.attributes=t,this.clear()}function $(e,t){this.key=e,this.attributes=t,this.clear()}function k(e,t){this.key=e,this.attributes=t,this.clear()}function v(e,t,r,i,n){this.key=t,this.attributes=n,this.undirected=e,this.source=r,this.target=i}function G(e,t,r,i,n,o,d){let a,s,u,h;if(i=""+i,0===r){if(!(a=e._nodes.get(i)))throw new b(`Graph.${t}: could not find the "${i}" node in the graph.`);u=n,h=o}else if(3===r){if(n=""+n,!(s=e._edges.get(n)))throw new b(`Graph.${t}: could not find the "${n}" edge in the graph.`);let r=s.source.key,l=s.target.key;if(i===r)a=s.target;else if(i===l)a=s.source;else throw new b(`Graph.${t}: the "${i}" node is not attached to the "${n}" edge (${r}, ${l}).`);u=o,h=d}else{if(!(s=e._edges.get(i)))throw new b(`Graph.${t}: could not find the "${i}" edge in the graph.`);a=1===r?s.source:s.target,u=n,h=o}return[a,u,h]}x.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.undirectedDegree=0,this.undirectedLoops=0,this.directedLoops=0,this.in={},this.out={},this.undirected={}},$.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.directedLoops=0,this.in={},this.out={}},k.prototype.clear=function(){this.undirectedDegree=0,this.undirectedLoops=0,this.undirected={}},v.prototype.attach=function(){let e="out",t="in";this.undirected&&(e=t="undirected");let r=this.source.key,i=this.target.key;this.source[e][i]=this,this.undirected&&r===i||(this.target[t][r]=this)},v.prototype.attachMulti=function(){let e="out",t="in",r=this.source.key,i=this.target.key;this.undirected&&(e=t="undirected");let n=this.source[e],o=n[i];if(void 0===o){n[i]=this,this.undirected&&r===i||(this.target[t][r]=this);return}o.previous=this,this.next=o,n[i]=this,this.target[t][r]=this},v.prototype.detach=function(){let e=this.source.key,t=this.target.key,r="out",i="in";this.undirected&&(r=i="undirected"),delete this.source[r][t],delete this.target[i][e]},v.prototype.detachMulti=function(){let e=this.source.key,t=this.target.key,r="out",i="in";this.undirected&&(r=i="undirected"),void 0===this.previous?void 0===this.next?(delete this.source[r][t],delete this.target[i][e]):(this.next.previous=void 0,this.source[r][t]=this.next,this.target[i][e]=this.next):(this.previous.next=this.next,void 0!==this.next&&(this.next.previous=this.previous))};let _=[{name:e=>`get${e}Attribute`,attacher:function(e,t,r){e.prototype[t]=function(e,i,n){let[o,d]=G(this,t,r,e,i,n);return o.attributes[d]}}},{name:e=>`get${e}Attributes`,attacher:function(e,t,r){e.prototype[t]=function(e,i){let[n]=G(this,t,r,e,i);return n.attributes}}},{name:e=>`has${e}Attribute`,attacher:function(e,t,r){e.prototype[t]=function(e,i,n){let[o,d]=G(this,t,r,e,i,n);return o.attributes.hasOwnProperty(d)}}},{name:e=>`set${e}Attribute`,attacher:function(e,t,r){e.prototype[t]=function(e,i,n,o){let[d,a,s]=G(this,t,r,e,i,n,o);return d.attributes[a]=s,this.emit("nodeAttributesUpdated",{key:d.key,type:"set",attributes:d.attributes,name:a}),this}}},{name:e=>`update${e}Attribute`,attacher:function(e,t,r){e.prototype[t]=function(e,i,n,o){let[d,a,s]=G(this,t,r,e,i,n,o);if("function"!=typeof s)throw new m(`Graph.${t}: updater should be a function.`);let u=d.attributes,h=s(u[a]);return u[a]=h,this.emit("nodeAttributesUpdated",{key:d.key,type:"set",attributes:d.attributes,name:a}),this}}},{name:e=>`remove${e}Attribute`,attacher:function(e,t,r){e.prototype[t]=function(e,i,n){let[o,d]=G(this,t,r,e,i,n);return delete o.attributes[d],this.emit("nodeAttributesUpdated",{key:o.key,type:"remove",attributes:o.attributes,name:d}),this}}},{name:e=>`replace${e}Attributes`,attacher:function(e,t,r){e.prototype[t]=function(e,i,n){let[o,d]=G(this,t,r,e,i,n);if(!u(d))throw new m(`Graph.${t}: provided attributes are not a plain object.`);return o.attributes=d,this.emit("nodeAttributesUpdated",{key:o.key,type:"replace",attributes:o.attributes}),this}}},{name:e=>`merge${e}Attributes`,attacher:function(e,t,r){e.prototype[t]=function(e,i,n){let[o,d]=G(this,t,r,e,i,n);if(!u(d))throw new m(`Graph.${t}: provided attributes are not a plain object.`);return a(o.attributes,d),this.emit("nodeAttributesUpdated",{key:o.key,type:"merge",attributes:o.attributes,data:d}),this}}},{name:e=>`update${e}Attributes`,attacher:function(e,t,r){e.prototype[t]=function(e,i,n){let[o,d]=G(this,t,r,e,i,n);if("function"!=typeof d)throw new m(`Graph.${t}: provided updater is not a function.`);return o.attributes=d(o.attributes),this.emit("nodeAttributesUpdated",{key:o.key,type:"update",attributes:o.attributes}),this}}}],E=[{name:e=>`get${e}Attribute`,attacher:function(e,t,r){e.prototype[t]=function(e,i){let n;if("mixed"!==this.type&&"mixed"!==r&&r!==this.type)throw new w(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new w(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);let o=""+e,d=""+i;if(i=arguments[2],!(n=s(this,o,d,r)))throw new b(`Graph.${t}: could not find an edge for the given path ("${o}" - "${d}").`)}else{if("mixed"!==r)throw new w(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,!(n=this._edges.get(e)))throw new b(`Graph.${t}: could not find the "${e}" edge in the graph.`)}return n.attributes[i]}}},{name:e=>`get${e}Attributes`,attacher:function(e,t,r){e.prototype[t]=function(e){let i;if("mixed"!==this.type&&"mixed"!==r&&r!==this.type)throw new w(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>1){if(this.multi)throw new w(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);let n=""+e,o=""+arguments[1];if(!(i=s(this,n,o,r)))throw new b(`Graph.${t}: could not find an edge for the given path ("${n}" - "${o}").`)}else{if("mixed"!==r)throw new w(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,!(i=this._edges.get(e)))throw new b(`Graph.${t}: could not find the "${e}" edge in the graph.`)}return i.attributes}}},{name:e=>`has${e}Attribute`,attacher:function(e,t,r){e.prototype[t]=function(e,i){let n;if("mixed"!==this.type&&"mixed"!==r&&r!==this.type)throw new w(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new w(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);let o=""+e,d=""+i;if(i=arguments[2],!(n=s(this,o,d,r)))throw new b(`Graph.${t}: could not find an edge for the given path ("${o}" - "${d}").`)}else{if("mixed"!==r)throw new w(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,!(n=this._edges.get(e)))throw new b(`Graph.${t}: could not find the "${e}" edge in the graph.`)}return n.attributes.hasOwnProperty(i)}}},{name:e=>`set${e}Attribute`,attacher:function(e,t,r){e.prototype[t]=function(e,i,n){let o;if("mixed"!==this.type&&"mixed"!==r&&r!==this.type)throw new w(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new w(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);let d=""+e,a=""+i;if(i=arguments[2],n=arguments[3],!(o=s(this,d,a,r)))throw new b(`Graph.${t}: could not find an edge for the given path ("${d}" - "${a}").`)}else{if("mixed"!==r)throw new w(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,!(o=this._edges.get(e)))throw new b(`Graph.${t}: could not find the "${e}" edge in the graph.`)}return o.attributes[i]=n,this.emit("edgeAttributesUpdated",{key:o.key,type:"set",attributes:o.attributes,name:i}),this}}},{name:e=>`update${e}Attribute`,attacher:function(e,t,r){e.prototype[t]=function(e,i,n){let o;if("mixed"!==this.type&&"mixed"!==r&&r!==this.type)throw new w(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new w(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);let d=""+e,a=""+i;if(i=arguments[2],n=arguments[3],!(o=s(this,d,a,r)))throw new b(`Graph.${t}: could not find an edge for the given path ("${d}" - "${a}").`)}else{if("mixed"!==r)throw new w(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,!(o=this._edges.get(e)))throw new b(`Graph.${t}: could not find the "${e}" edge in the graph.`)}if("function"!=typeof n)throw new m(`Graph.${t}: updater should be a function.`);return o.attributes[i]=n(o.attributes[i]),this.emit("edgeAttributesUpdated",{key:o.key,type:"set",attributes:o.attributes,name:i}),this}}},{name:e=>`remove${e}Attribute`,attacher:function(e,t,r){e.prototype[t]=function(e,i){let n;if("mixed"!==this.type&&"mixed"!==r&&r!==this.type)throw new w(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new w(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);let o=""+e,d=""+i;if(i=arguments[2],!(n=s(this,o,d,r)))throw new b(`Graph.${t}: could not find an edge for the given path ("${o}" - "${d}").`)}else{if("mixed"!==r)throw new w(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,!(n=this._edges.get(e)))throw new b(`Graph.${t}: could not find the "${e}" edge in the graph.`)}return delete n.attributes[i],this.emit("edgeAttributesUpdated",{key:n.key,type:"remove",attributes:n.attributes,name:i}),this}}},{name:e=>`replace${e}Attributes`,attacher:function(e,t,r){e.prototype[t]=function(e,i){let n;if("mixed"!==this.type&&"mixed"!==r&&r!==this.type)throw new w(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new w(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);let o=""+e,d=""+i;if(i=arguments[2],!(n=s(this,o,d,r)))throw new b(`Graph.${t}: could not find an edge for the given path ("${o}" - "${d}").`)}else{if("mixed"!==r)throw new w(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,!(n=this._edges.get(e)))throw new b(`Graph.${t}: could not find the "${e}" edge in the graph.`)}if(!u(i))throw new m(`Graph.${t}: provided attributes are not a plain object.`);return n.attributes=i,this.emit("edgeAttributesUpdated",{key:n.key,type:"replace",attributes:n.attributes}),this}}},{name:e=>`merge${e}Attributes`,attacher:function(e,t,r){e.prototype[t]=function(e,i){let n;if("mixed"!==this.type&&"mixed"!==r&&r!==this.type)throw new w(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new w(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);let o=""+e,d=""+i;if(i=arguments[2],!(n=s(this,o,d,r)))throw new b(`Graph.${t}: could not find an edge for the given path ("${o}" - "${d}").`)}else{if("mixed"!==r)throw new w(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,!(n=this._edges.get(e)))throw new b(`Graph.${t}: could not find the "${e}" edge in the graph.`)}if(!u(i))throw new m(`Graph.${t}: provided attributes are not a plain object.`);return a(n.attributes,i),this.emit("edgeAttributesUpdated",{key:n.key,type:"merge",attributes:n.attributes,data:i}),this}}},{name:e=>`update${e}Attributes`,attacher:function(e,t,r){e.prototype[t]=function(e,i){let n;if("mixed"!==this.type&&"mixed"!==r&&r!==this.type)throw new w(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new w(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);let o=""+e,d=""+i;if(i=arguments[2],!(n=s(this,o,d,r)))throw new b(`Graph.${t}: could not find an edge for the given path ("${o}" - "${d}").`)}else{if("mixed"!==r)throw new w(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,!(n=this._edges.get(e)))throw new b(`Graph.${t}: could not find the "${e}" edge in the graph.`)}if("function"!=typeof i)throw new m(`Graph.${t}: provided updater is not a function.`);return n.attributes=i(n.attributes),this.emit("edgeAttributesUpdated",{key:n.key,type:"update",attributes:n.attributes}),this}}}];function A(e,t,r,i){let n=!1;for(let o in t){if(o===i)continue;let d=t[o];if(n=r(d.key,d.attributes,d.source.key,d.target.key,d.source.attributes,d.target.attributes,d.undirected),e&&n)return d.key}}function S(e,t,r,i){let n,o,d,a=!1;for(let s in t)if(s!==i){n=t[s];do{if(o=n.source,d=n.target,a=r(n.key,n.attributes,o.key,d.key,o.attributes,d.attributes,n.undirected),e&&a)return n.key;n=n.next}while(void 0!==n)}}function N(e,t){let r,i=Object.keys(e),n=i.length,o=0;return{[Symbol.iterator](){return this},next(){do if(r)r=r.next;else{if(o>=n)return{done:!0};let d=i[o++];if(d===t){r=void 0;continue}r=e[d]}while(!r)return{done:!1,value:{edge:r.key,attributes:r.attributes,source:r.source.key,target:r.target.key,sourceAttributes:r.source.attributes,targetAttributes:r.target.attributes,undirected:r.undirected}}}}}function D(e,t,r,i){let n=t[r];if(!n)return;let o=n.source,d=n.target;if(i(n.key,n.attributes,o.key,d.key,o.attributes,d.attributes,n.undirected)&&e)return n.key}function C(e,t,r,i){let n=t[r];if(!n)return;let o=!1;do{if(o=i(n.key,n.attributes,n.source.key,n.target.key,n.source.attributes,n.target.attributes,n.undirected),e&&o)return n.key;n=n.next}while(void 0!==n)}function L(e,t){let r=e[t];if(void 0!==r.next)return{[Symbol.iterator](){return this},next(){if(!r)return{done:!0};let e={edge:r.key,attributes:r.attributes,source:r.source.key,target:r.target.key,sourceAttributes:r.source.attributes,targetAttributes:r.target.attributes,undirected:r.undirected};return r=r.next,{done:!1,value:e}}};let i=!1;return{[Symbol.iterator](){return this},next:()=>!0===i?{done:!0}:(i=!0,{done:!1,value:{edge:r.key,attributes:r.attributes,source:r.source.key,target:r.target.key,sourceAttributes:r.source.attributes,targetAttributes:r.target.attributes,undirected:r.undirected}})}}function U(e,t,r,i){let n,o;if(0===t.size)return;let d="mixed"!==r&&r!==t.type,a="undirected"===r,s=!1,u=t._edges.values();for(;!0!==(n=u.next()).done;){if(o=n.value,d&&o.undirected!==a)continue;let{key:t,attributes:r,source:u,target:h}=o;if(s=i(t,r,u.key,h.key,u.attributes,h.attributes,o.undirected),e&&s)return t}}function M(e,t,r,i,n,o){let d,a=t?S:A;if("undirected"!==r&&("out"!==i&&(d=a(e,n.in,o),e&&d)||"in"!==i&&(d=a(e,n.out,o,i?void 0:n.key),e&&d)))return d;if("directed"!==r&&(d=a(e,n.undirected,o),e&&d))return d}function z(e,t,r,i,n,o,d){let a,s=r?C:D;if("undirected"!==t&&(void 0!==n.in&&"out"!==i&&(a=s(e,n.in,o,d),e&&a)||void 0!==n.out&&"in"!==i&&(i||n.key!==o)&&(a=s(e,n.out,o,d),e&&a)))return a;if("directed"!==t&&void 0!==n.undirected&&(a=s(e,n.undirected,o,d),e&&a))return a}function j(){this.A=null,this.B=null}function I(e,t,r,i,n){for(let o in i){let d=i[o],a=d.source,s=d.target,u=a===r?s:a;if(t&&t.has(u.key))continue;let h=n(u.key,u.attributes);if(e&&h)return u.key}}function W(e,t,r,i,n){let o;if("mixed"!==t){if("undirected"===t)return I(e,null,i,i.undirected,n);if("string"==typeof r)return I(e,null,i,i[r],n)}let d=new j;if("undirected"!==t){if("out"!==r){if(o=I(e,null,i,i.in,n),e&&o)return o;d.wrap(i.in)}if("in"!==r){if(o=I(e,d,i,i.out,n),e&&o)return o;d.wrap(i.out)}}if("directed"!==t&&(o=I(e,d,i,i.undirected,n),e&&o))return o}function O(e,t,r){let i=Object.keys(r),n=i.length,o=0;return{[Symbol.iterator](){return this},next(){let d=null;do{if(o>=n)return e&&e.wrap(r),{done:!0};let a=r[i[o++]],s=a.source,u=a.target;if(d=s===t?u:s,e&&e.has(d.key)){d=null;continue}}while(null===d)return{done:!1,value:{neighbor:d.key,attributes:d.attributes}}}}}function P(e,t,r,i,n){let o,d,a,s,u,h,l,c=i._nodes.values(),p=i.type;for(;!0!==(o=c.next()).done;){let i=!1;if(d=o.value,"undirected"!==p)for(a in s=d.out){u=s[a];do{if(h=u.target,i=!0,l=n(d.key,h.key,d.attributes,h.attributes,u.key,u.attributes,u.undirected),e&&l)return u;u=u.next}while(u)}if("directed"!==p){for(a in s=d.undirected)if(!t||!(d.key>a)){u=s[a];do{if((h=u.target).key!==a&&(h=u.source),i=!0,l=n(d.key,h.key,d.attributes,h.attributes,u.key,u.attributes,u.undirected),e&&l)return u;u=u.next}while(u)}}if(r&&!i&&(l=n(d.key,null,d.attributes,null,null,null,null),e&&l))return null}}j.prototype.wrap=function(e){null===this.A?this.A=e:null===this.B&&(this.B=e)},j.prototype.has=function(e){return null!==this.A&&e in this.A||null!==this.B&&e in this.B};let R=(t=255&Math.floor(256*Math.random()),()=>t++),T=new Set(["directed","undirected","mixed"]),K=new Set(["domain","_events","_eventsCount","_maxListeners"]),F={allowSelfLoops:!0,multi:!1,type:"mixed"};function B(e,t,r){let i=new e.NodeDataClass(t,r);return e._nodes.set(t,i),e.emit("nodeAdded",{key:t,attributes:r}),i}function Y(e,t,r,i,n,o,d,a){if(!i&&"undirected"===e.type)throw new w(`Graph.${t}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);if(i&&"directed"===e.type)throw new w(`Graph.${t}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);if(a&&!u(a))throw new m(`Graph.${t}: invalid attributes. Expecting an object but got "${a}"`);if(o=""+o,d=""+d,a=a||{},!e.allowSelfLoops&&o===d)throw new w(`Graph.${t}: source & target are the same ("${o}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);let s=e._nodes.get(o),h=e._nodes.get(d);if(!s)throw new b(`Graph.${t}: source node "${o}" not found.`);if(!h)throw new b(`Graph.${t}: target node "${d}" not found.`);let l={key:null,undirected:i,source:o,target:d,attributes:a};if(r)n=e._edgeKeyGenerator();else if(n=""+n,e._edges.has(n))throw new w(`Graph.${t}: the "${n}" edge already exists in the graph.`);if(!e.multi&&(i?void 0!==s.undirected[d]:void 0!==s.out[d]))throw new w(`Graph.${t}: an edge linking "${o}" to "${d}" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`);let c=new v(i,n,s,h,a);e._edges.set(n,c);let p=o===d;return i?(s.undirectedDegree++,h.undirectedDegree++,p&&(s.undirectedLoops++,e._undirectedSelfLoopCount++)):(s.outDegree++,h.inDegree++,p&&(s.directedLoops++,e._directedSelfLoopCount++)),e.multi?c.attachMulti():c.attach(),i?e._undirectedSize++:e._directedSize++,l.key=n,e.emit("edgeAdded",l),n}function Z(e,t,r,i,n,o,d,s,h){let l,c,p;if(!i&&"undirected"===e.type)throw new w(`Graph.${t}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`);if(i&&"directed"===e.type)throw new w(`Graph.${t}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`);if(s){if(h){if("function"!=typeof s)throw new m(`Graph.${t}: invalid updater function. Expecting a function but got "${s}"`)}else if(!u(s))throw new m(`Graph.${t}: invalid attributes. Expecting an object but got "${s}"`)}if(o=""+o,d=""+d,h&&(l=s,s=void 0),!e.allowSelfLoops&&o===d)throw new w(`Graph.${t}: source & target are the same ("${o}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);let g=e._nodes.get(o),f=e._nodes.get(d);if(!r&&(c=e._edges.get(n))){if((c.source.key!==o||c.target.key!==d)&&(!i||c.source.key!==d||c.target.key!==o))throw new w(`Graph.${t}: inconsistency detected when attempting to merge the "${n}" edge with "${o}" source & "${d}" target vs. ("${c.source.key}", "${c.target.key}").`);p=c}if(p||e.multi||!g||(p=i?g.undirected[d]:g.out[d]),p){let t=[p.key,!1,!1,!1];if(h?!l:!s)return t;if(h){let t=p.attributes;p.attributes=l(t),e.emit("edgeAttributesUpdated",{type:"replace",key:p.key,attributes:p.attributes})}else a(p.attributes,s),e.emit("edgeAttributesUpdated",{type:"merge",key:p.key,attributes:p.attributes,data:s});return t}s=s||{},h&&l&&(s=l(s));let y={key:null,undirected:i,source:o,target:d,attributes:s};if(r)n=e._edgeKeyGenerator();else if(n=""+n,e._edges.has(n))throw new w(`Graph.${t}: the "${n}" edge already exists in the graph.`);let b=!1,x=!1;g||(g=B(e,o,{}),b=!0,o===d&&(f=g,x=!0)),f||(f=B(e,d,{}),x=!0),c=new v(i,n,g,f,s),e._edges.set(n,c);let $=o===d;return i?(g.undirectedDegree++,f.undirectedDegree++,$&&(g.undirectedLoops++,e._undirectedSelfLoopCount++)):(g.outDegree++,f.inDegree++,$&&(g.directedLoops++,e._directedSelfLoopCount++)),e.multi?c.attachMulti():c.attach(),i?e._undirectedSize++:e._directedSize++,y.key=n,e.emit("edgeAdded",y),[n,!0,b,x]}function q(e,t){e._edges.delete(t.key);let{source:r,target:i,attributes:n}=t,o=t.undirected,d=r===i;o?(r.undirectedDegree--,i.undirectedDegree--,d&&(r.undirectedLoops--,e._undirectedSelfLoopCount--)):(r.outDegree--,i.inDegree--,d&&(r.directedLoops--,e._directedSelfLoopCount--)),e.multi?t.detachMulti():t.detach(),o?e._undirectedSize--:e._directedSize--,e.emit("edgeDropped",{key:t.key,attributes:n,source:r.key,target:i.key,undirected:o})}class V extends d.EventEmitter{constructor(e){if(super(),"boolean"!=typeof(e=a({},F,e)).multi)throw new m(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got "${e.multi}".`);if(!T.has(e.type))throw new m(`Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "${e.type}".`);if("boolean"!=typeof e.allowSelfLoops)throw new m(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "${e.allowSelfLoops}".`);l(this,"NodeDataClass","mixed"===e.type?x:"directed"===e.type?$:k);const t="geid_"+R()+"_";let r=0;const i=()=>{let e;do e=t+r++;while(this._edges.has(e))return e};l(this,"_attributes",{}),l(this,"_nodes",new Map),l(this,"_edges",new Map),l(this,"_directedSize",0),l(this,"_undirectedSize",0),l(this,"_directedSelfLoopCount",0),l(this,"_undirectedSelfLoopCount",0),l(this,"_edgeKeyGenerator",i),l(this,"_options",e),K.forEach(e=>l(this,e,this[e])),c(this,"order",()=>this._nodes.size),c(this,"size",()=>this._edges.size),c(this,"directedSize",()=>this._directedSize),c(this,"undirectedSize",()=>this._undirectedSize),c(this,"selfLoopCount",()=>this._directedSelfLoopCount+this._undirectedSelfLoopCount),c(this,"directedSelfLoopCount",()=>this._directedSelfLoopCount),c(this,"undirectedSelfLoopCount",()=>this._undirectedSelfLoopCount),c(this,"multi",this._options.multi),c(this,"type",this._options.type),c(this,"allowSelfLoops",this._options.allowSelfLoops),c(this,"implementation",()=>"graphology")}_resetInstanceCounters(){this._directedSize=0,this._undirectedSize=0,this._directedSelfLoopCount=0,this._undirectedSelfLoopCount=0}hasNode(e){return this._nodes.has(""+e)}hasDirectedEdge(e,t){if("undirected"===this.type)return!1;if(1==arguments.length){let t=""+e,r=this._edges.get(t);return!!r&&!r.undirected}if(2==arguments.length){e=""+e,t=""+t;let r=this._nodes.get(e);return!!r&&r.out.hasOwnProperty(t)}throw new m(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasUndirectedEdge(e,t){if("directed"===this.type)return!1;if(1==arguments.length){let t=""+e,r=this._edges.get(t);return!!r&&r.undirected}if(2==arguments.length){e=""+e,t=""+t;let r=this._nodes.get(e);return!!r&&r.undirected.hasOwnProperty(t)}throw new m(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasEdge(e,t){if(1==arguments.length){let t=""+e;return this._edges.has(t)}if(2==arguments.length){e=""+e,t=""+t;let r=this._nodes.get(e);return!!r&&(void 0!==r.out&&r.out.hasOwnProperty(t)||void 0!==r.undirected&&r.undirected.hasOwnProperty(t))}throw new m(`Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}directedEdge(e,t){if("undirected"===this.type)return;if(e=""+e,t=""+t,this.multi)throw new w("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.");let r=this._nodes.get(e);if(!r)throw new b(`Graph.directedEdge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new b(`Graph.directedEdge: could not find the "${t}" target node in the graph.`);let i=r.out&&r.out[t]||void 0;if(i)return i.key}undirectedEdge(e,t){if("directed"===this.type)return;if(e=""+e,t=""+t,this.multi)throw new w("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.");let r=this._nodes.get(e);if(!r)throw new b(`Graph.undirectedEdge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new b(`Graph.undirectedEdge: could not find the "${t}" target node in the graph.`);let i=r.undirected&&r.undirected[t]||void 0;if(i)return i.key}edge(e,t){if(this.multi)throw new w("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.");e=""+e,t=""+t;let r=this._nodes.get(e);if(!r)throw new b(`Graph.edge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new b(`Graph.edge: could not find the "${t}" target node in the graph.`);let i=r.out&&r.out[t]||r.undirected&&r.undirected[t]||void 0;if(i)return i.key}areDirectedNeighbors(e,t){e=""+e,t=""+t;let r=this._nodes.get(e);if(!r)throw new b(`Graph.areDirectedNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&(t in r.in||t in r.out)}areOutNeighbors(e,t){e=""+e,t=""+t;let r=this._nodes.get(e);if(!r)throw new b(`Graph.areOutNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&t in r.out}areInNeighbors(e,t){e=""+e,t=""+t;let r=this._nodes.get(e);if(!r)throw new b(`Graph.areInNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&t in r.in}areUndirectedNeighbors(e,t){e=""+e,t=""+t;let r=this._nodes.get(e);if(!r)throw new b(`Graph.areUndirectedNeighbors: could not find the "${e}" node in the graph.`);return"directed"!==this.type&&t in r.undirected}areNeighbors(e,t){e=""+e,t=""+t;let r=this._nodes.get(e);if(!r)throw new b(`Graph.areNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&(t in r.in||t in r.out)||"directed"!==this.type&&t in r.undirected}areInboundNeighbors(e,t){e=""+e,t=""+t;let r=this._nodes.get(e);if(!r)throw new b(`Graph.areInboundNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&t in r.in||"directed"!==this.type&&t in r.undirected}areOutboundNeighbors(e,t){e=""+e,t=""+t;let r=this._nodes.get(e);if(!r)throw new b(`Graph.areOutboundNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&t in r.out||"directed"!==this.type&&t in r.undirected}inDegree(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new b(`Graph.inDegree: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.inDegree}outDegree(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new b(`Graph.outDegree: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.outDegree}directedDegree(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new b(`Graph.directedDegree: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.inDegree+t.outDegree}undirectedDegree(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new b(`Graph.undirectedDegree: could not find the "${e}" node in the graph.`);return"directed"===this.type?0:t.undirectedDegree}inboundDegree(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new b(`Graph.inboundDegree: could not find the "${e}" node in the graph.`);let r=0;return"directed"!==this.type&&(r+=t.undirectedDegree),"undirected"!==this.type&&(r+=t.inDegree),r}outboundDegree(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new b(`Graph.outboundDegree: could not find the "${e}" node in the graph.`);let r=0;return"directed"!==this.type&&(r+=t.undirectedDegree),"undirected"!==this.type&&(r+=t.outDegree),r}degree(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new b(`Graph.degree: could not find the "${e}" node in the graph.`);let r=0;return"directed"!==this.type&&(r+=t.undirectedDegree),"undirected"!==this.type&&(r+=t.inDegree+t.outDegree),r}inDegreeWithoutSelfLoops(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new b(`Graph.inDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.inDegree-t.directedLoops}outDegreeWithoutSelfLoops(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new b(`Graph.outDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.outDegree-t.directedLoops}directedDegreeWithoutSelfLoops(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new b(`Graph.directedDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.inDegree+t.outDegree-2*t.directedLoops}undirectedDegreeWithoutSelfLoops(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new b(`Graph.undirectedDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return"directed"===this.type?0:t.undirectedDegree-2*t.undirectedLoops}inboundDegreeWithoutSelfLoops(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new b(`Graph.inboundDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let r=0,i=0;return"directed"!==this.type&&(r+=t.undirectedDegree,i+=2*t.undirectedLoops),"undirected"!==this.type&&(r+=t.inDegree,i+=t.directedLoops),r-i}outboundDegreeWithoutSelfLoops(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new b(`Graph.outboundDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let r=0,i=0;return"directed"!==this.type&&(r+=t.undirectedDegree,i+=2*t.undirectedLoops),"undirected"!==this.type&&(r+=t.outDegree,i+=t.directedLoops),r-i}degreeWithoutSelfLoops(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new b(`Graph.degreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let r=0,i=0;return"directed"!==this.type&&(r+=t.undirectedDegree,i+=2*t.undirectedLoops),"undirected"!==this.type&&(r+=t.inDegree+t.outDegree,i+=2*t.directedLoops),r-i}source(e){e=""+e;let t=this._edges.get(e);if(!t)throw new b(`Graph.source: could not find the "${e}" edge in the graph.`);return t.source.key}target(e){e=""+e;let t=this._edges.get(e);if(!t)throw new b(`Graph.target: could not find the "${e}" edge in the graph.`);return t.target.key}extremities(e){e=""+e;let t=this._edges.get(e);if(!t)throw new b(`Graph.extremities: could not find the "${e}" edge in the graph.`);return[t.source.key,t.target.key]}opposite(e,t){e=""+e,t=""+t;let r=this._edges.get(t);if(!r)throw new b(`Graph.opposite: could not find the "${t}" edge in the graph.`);let i=r.source.key,n=r.target.key;if(e===i)return n;if(e===n)return i;throw new b(`Graph.opposite: the "${e}" node is not attached to the "${t}" edge (${i}, ${n}).`)}hasExtremity(e,t){e=""+e,t=""+t;let r=this._edges.get(e);if(!r)throw new b(`Graph.hasExtremity: could not find the "${e}" edge in the graph.`);return r.source.key===t||r.target.key===t}isUndirected(e){e=""+e;let t=this._edges.get(e);if(!t)throw new b(`Graph.isUndirected: could not find the "${e}" edge in the graph.`);return t.undirected}isDirected(e){e=""+e;let t=this._edges.get(e);if(!t)throw new b(`Graph.isDirected: could not find the "${e}" edge in the graph.`);return!t.undirected}isSelfLoop(e){e=""+e;let t=this._edges.get(e);if(!t)throw new b(`Graph.isSelfLoop: could not find the "${e}" edge in the graph.`);return t.source===t.target}addNode(e,t){return function(e,t,r){if(r&&!u(r))throw new m(`Graph.addNode: invalid attributes. Expecting an object but got "${r}"`);if(t=""+t,r=r||{},e._nodes.has(t))throw new w(`Graph.addNode: the "${t}" node already exist in the graph.`);let i=new e.NodeDataClass(t,r);return e._nodes.set(t,i),e.emit("nodeAdded",{key:t,attributes:r}),i}(this,e,t).key}mergeNode(e,t){if(t&&!u(t))throw new m(`Graph.mergeNode: invalid attributes. Expecting an object but got "${t}"`);e=""+e,t=t||{};let r=this._nodes.get(e);return r?(t&&(a(r.attributes,t),this.emit("nodeAttributesUpdated",{type:"merge",key:e,attributes:r.attributes,data:t})),[e,!1]):(r=new this.NodeDataClass(e,t),this._nodes.set(e,r),this.emit("nodeAdded",{key:e,attributes:t}),[e,!0])}updateNode(e,t){if(t&&"function"!=typeof t)throw new m(`Graph.updateNode: invalid updater function. Expecting a function but got "${t}"`);e=""+e;let r=this._nodes.get(e);if(r){if(t){let i=r.attributes;r.attributes=t(i),this.emit("nodeAttributesUpdated",{type:"replace",key:e,attributes:r.attributes})}return[e,!1]}let i=t?t({}):{};return r=new this.NodeDataClass(e,i),this._nodes.set(e,r),this.emit("nodeAdded",{key:e,attributes:i}),[e,!0]}dropNode(e){let t;e=""+e;let r=this._nodes.get(e);if(!r)throw new b(`Graph.dropNode: could not find the "${e}" node in the graph.`);if("undirected"!==this.type){for(let e in r.out){t=r.out[e];do q(this,t),t=t.next;while(t)}for(let e in r.in){t=r.in[e];do q(this,t),t=t.next;while(t)}}if("directed"!==this.type)for(let e in r.undirected){t=r.undirected[e];do q(this,t),t=t.next;while(t)}this._nodes.delete(e),this.emit("nodeDropped",{key:e,attributes:r.attributes})}dropEdge(e){let t;if(arguments.length>1){let e=""+arguments[0],r=""+arguments[1];if(!(t=s(this,e,r,this.type)))throw new b(`Graph.dropEdge: could not find the "${e}" -> "${r}" edge in the graph.`)}else if(e=""+e,!(t=this._edges.get(e)))throw new b(`Graph.dropEdge: could not find the "${e}" edge in the graph.`);return q(this,t),this}dropDirectedEdge(e,t){if(arguments.length<2)throw new w("Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new w("Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");let r=s(this,e=""+e,t=""+t,"directed");if(!r)throw new b(`Graph.dropDirectedEdge: could not find a "${e}" -> "${t}" edge in the graph.`);return q(this,r),this}dropUndirectedEdge(e,t){if(arguments.length<2)throw new w("Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new w("Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");let r=s(this,e,t,"undirected");if(!r)throw new b(`Graph.dropUndirectedEdge: could not find a "${e}" -> "${t}" edge in the graph.`);return q(this,r),this}clear(){this._edges.clear(),this._nodes.clear(),this._resetInstanceCounters(),this.emit("cleared")}clearEdges(){let e,t=this._nodes.values();for(;!0!==(e=t.next()).done;)e.value.clear();this._edges.clear(),this._resetInstanceCounters(),this.emit("edgesCleared")}getAttribute(e){return this._attributes[e]}getAttributes(){return this._attributes}hasAttribute(e){return this._attributes.hasOwnProperty(e)}setAttribute(e,t){return this._attributes[e]=t,this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this}updateAttribute(e,t){if("function"!=typeof t)throw new m("Graph.updateAttribute: updater should be a function.");let r=this._attributes[e];return this._attributes[e]=t(r),this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this}removeAttribute(e){return delete this._attributes[e],this.emit("attributesUpdated",{type:"remove",attributes:this._attributes,name:e}),this}replaceAttributes(e){if(!u(e))throw new m("Graph.replaceAttributes: provided attributes are not a plain object.");return this._attributes=e,this.emit("attributesUpdated",{type:"replace",attributes:this._attributes}),this}mergeAttributes(e){if(!u(e))throw new m("Graph.mergeAttributes: provided attributes are not a plain object.");return a(this._attributes,e),this.emit("attributesUpdated",{type:"merge",attributes:this._attributes,data:e}),this}updateAttributes(e){if("function"!=typeof e)throw new m("Graph.updateAttributes: provided updater is not a function.");return this._attributes=e(this._attributes),this.emit("attributesUpdated",{type:"update",attributes:this._attributes}),this}updateEachNodeAttributes(e,t){let r,i;if("function"!=typeof e)throw new m("Graph.updateEachNodeAttributes: expecting an updater function.");if(t&&!p(t))throw new m("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");let n=this._nodes.values();for(;!0!==(r=n.next()).done;)(i=r.value).attributes=e(i.key,i.attributes);this.emit("eachNodeAttributesUpdated",{hints:t||null})}updateEachEdgeAttributes(e,t){let r,i,n,o;if("function"!=typeof e)throw new m("Graph.updateEachEdgeAttributes: expecting an updater function.");if(t&&!p(t))throw new m("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");let d=this._edges.values();for(;!0!==(r=d.next()).done;)n=(i=r.value).source,o=i.target,i.attributes=e(i.key,i.attributes,n.key,o.key,n.attributes,o.attributes,i.undirected);this.emit("eachEdgeAttributesUpdated",{hints:t||null})}forEachAdjacencyEntry(e){if("function"!=typeof e)throw new m("Graph.forEachAdjacencyEntry: expecting a callback.");P(!1,!1,!1,this,e)}forEachAdjacencyEntryWithOrphans(e){if("function"!=typeof e)throw new m("Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.");P(!1,!1,!0,this,e)}forEachAssymetricAdjacencyEntry(e){if("function"!=typeof e)throw new m("Graph.forEachAssymetricAdjacencyEntry: expecting a callback.");P(!1,!0,!1,this,e)}forEachAssymetricAdjacencyEntryWithOrphans(e){if("function"!=typeof e)throw new m("Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.");P(!1,!0,!0,this,e)}nodes(){return Array.from(this._nodes.keys())}forEachNode(e){let t,r;if("function"!=typeof e)throw new m("Graph.forEachNode: expecting a callback.");let i=this._nodes.values();for(;!0!==(t=i.next()).done;)e((r=t.value).key,r.attributes)}findNode(e){let t,r;if("function"!=typeof e)throw new m("Graph.findNode: expecting a callback.");let i=this._nodes.values();for(;!0!==(t=i.next()).done;)if(e((r=t.value).key,r.attributes))return r.key}mapNodes(e){let t,r;if("function"!=typeof e)throw new m("Graph.mapNode: expecting a callback.");let i=this._nodes.values(),n=Array(this.order),o=0;for(;!0!==(t=i.next()).done;)r=t.value,n[o++]=e(r.key,r.attributes);return n}someNode(e){let t,r;if("function"!=typeof e)throw new m("Graph.someNode: expecting a callback.");let i=this._nodes.values();for(;!0!==(t=i.next()).done;)if(e((r=t.value).key,r.attributes))return!0;return!1}everyNode(e){let t,r;if("function"!=typeof e)throw new m("Graph.everyNode: expecting a callback.");let i=this._nodes.values();for(;!0!==(t=i.next()).done;)if(!e((r=t.value).key,r.attributes))return!1;return!0}filterNodes(e){let t,r;if("function"!=typeof e)throw new m("Graph.filterNodes: expecting a callback.");let i=this._nodes.values(),n=[];for(;!0!==(t=i.next()).done;)e((r=t.value).key,r.attributes)&&n.push(r.key);return n}reduceNodes(e,t){let r,i;if("function"!=typeof e)throw new m("Graph.reduceNodes: expecting a callback.");if(arguments.length<2)throw new m("Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.");let n=t,o=this._nodes.values();for(;!0!==(r=o.next()).done;)n=e(n,(i=r.value).key,i.attributes);return n}nodeEntries(){let e=this._nodes.values();return{[Symbol.iterator](){return this},next(){let t=e.next();if(t.done)return t;let r=t.value;return{value:{node:r.key,attributes:r.attributes},done:!1}}}}export(){let e=Array(this._nodes.size),t=0;this._nodes.forEach((r,i)=>{let n;e[t++]=(n={key:i},h(r.attributes)||(n.attributes=a({},r.attributes)),n)});let r=Array(this._edges.size);return t=0,this._edges.forEach((e,i)=>{var n;let o;r[t++]=(n=this.type,o={key:i,source:e.source.key,target:e.target.key},h(e.attributes)||(o.attributes=a({},e.attributes)),"mixed"===n&&e.undirected&&(o.undirected=!0),o)}),{options:{type:this.type,multi:this.multi,allowSelfLoops:this.allowSelfLoops},attributes:this.getAttributes(),nodes:e,edges:r}}import(e,t=!1){let r,i,n,o,d;if(e instanceof V)return e.forEachNode((e,r)=>{t?this.mergeNode(e,r):this.addNode(e,r)}),e.forEachEdge((e,r,i,n,o,d,a)=>{t?a?this.mergeUndirectedEdgeWithKey(e,i,n,r):this.mergeDirectedEdgeWithKey(e,i,n,r):a?this.addUndirectedEdgeWithKey(e,i,n,r):this.addDirectedEdgeWithKey(e,i,n,r)}),this;if(!u(e))throw new m("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");if(e.attributes){if(!u(e.attributes))throw new m("Graph.import: invalid attributes. Expecting a plain object.");t?this.mergeAttributes(e.attributes):this.replaceAttributes(e.attributes)}if(e.nodes){if(!Array.isArray(n=e.nodes))throw new m("Graph.import: invalid nodes. Expecting an array.");for(r=0,i=n.length;r<i;r++){var a=o=n[r];if(!u(a))throw new m('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');if(!("key"in a))throw new m("Graph.import: serialized node is missing its key.");if("attributes"in a&&(!u(a.attributes)||null===a.attributes))throw new m("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");let{key:e,attributes:i}=o;t?this.mergeNode(e,i):this.addNode(e,i)}}if(e.edges){let o=!1;if("undirected"===this.type&&(o=!0),!Array.isArray(n=e.edges))throw new m("Graph.import: invalid edges. Expecting an array.");for(r=0,i=n.length;r<i;r++){var s=d=n[r];if(!u(s))throw new m('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');if(!("source"in s))throw new m("Graph.import: serialized edge is missing its source.");if(!("target"in s))throw new m("Graph.import: serialized edge is missing its target.");if("attributes"in s&&(!u(s.attributes)||null===s.attributes))throw new m("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");if("undirected"in s&&"boolean"!=typeof s.undirected)throw new m("Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.");let{source:e,target:i,attributes:a,undirected:h=o}=d;"key"in d?(t?h?this.mergeUndirectedEdgeWithKey:this.mergeDirectedEdgeWithKey:h?this.addUndirectedEdgeWithKey:this.addDirectedEdgeWithKey).call(this,d.key,e,i,a):(t?h?this.mergeUndirectedEdge:this.mergeDirectedEdge:h?this.addUndirectedEdge:this.addDirectedEdge).call(this,e,i,a)}}return this}nullCopy(e){let t=new V(a({},this._options,e));return t.replaceAttributes(a({},this.getAttributes())),t}emptyCopy(e){let t=this.nullCopy(e);return this._nodes.forEach((e,r)=>{let i=a({},e.attributes);e=new t.NodeDataClass(r,i),t._nodes.set(r,e)}),t}copy(e){let t,r;if("string"==typeof(e=e||{}).type&&e.type!==this.type&&"mixed"!==e.type)throw new w(`Graph.copy: cannot create an incompatible copy from "${this.type}" type to "${e.type}" because this would mean losing information about the current graph.`);if("boolean"==typeof e.multi&&e.multi!==this.multi&&!0!==e.multi)throw new w("Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.");if("boolean"==typeof e.allowSelfLoops&&e.allowSelfLoops!==this.allowSelfLoops&&!0!==e.allowSelfLoops)throw new w("Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.");let i=this.emptyCopy(e),n=this._edges.values();for(;!0!==(t=n.next()).done;)Y(i,"copy",!1,(r=t.value).undirected,r.key,r.source.key,r.target.key,a({},r.attributes));return i}toJSON(){return this.export()}toString(){return"[object Graph]"}inspect(){let e={};this._nodes.forEach((t,r)=>{e[r]=t.attributes});let t={},r={};this._edges.forEach((e,i)=>{let n,o=e.undirected?"--":"->",d="",a=e.source.key,s=e.target.key;e.undirected&&a>s&&(n=a,a=s,s=n);let u=`(${a})${o}(${s})`;i.startsWith("geid_")?this.multi&&(void 0===r[u]?r[u]=0:r[u]++,d+=`${r[u]}. `):d+=`[${i}]: `,t[d+=u]=e.attributes});let i={};for(let e in this)this.hasOwnProperty(e)&&!K.has(e)&&"function"!=typeof this[e]&&"symbol"!=typeof e&&(i[e]=this[e]);return i.attributes=this._attributes,i.nodes=e,i.edges=t,l(i,"constructor",this.constructor),i}}"u">typeof Symbol&&(V.prototype[Symbol.for("nodejs.util.inspect.custom")]=V.prototype.inspect),[{name:e=>`${e}Edge`,generateKey:!0},{name:e=>`${e}DirectedEdge`,generateKey:!0,type:"directed"},{name:e=>`${e}UndirectedEdge`,generateKey:!0,type:"undirected"},{name:e=>`${e}EdgeWithKey`},{name:e=>`${e}DirectedEdgeWithKey`,type:"directed"},{name:e=>`${e}UndirectedEdgeWithKey`,type:"undirected"}].forEach(e=>{["add","merge","update"].forEach(t=>{let r=e.name(t),i="add"===t?Y:Z;e.generateKey?V.prototype[r]=function(n,o,d){return i(this,r,!0,"undirected"===(e.type||this.type),null,n,o,d,"update"===t)}:V.prototype[r]=function(n,o,d,a){return i(this,r,!1,"undirected"===(e.type||this.type),n,o,d,a,"update"===t)}})}),_.forEach(function({name:e,attacher:t}){t(V,e("Node"),0),t(V,e("Source"),1),t(V,e("Target"),2),t(V,e("Opposite"),3)}),E.forEach(function({name:e,attacher:t}){t(V,e("Edge"),"mixed"),t(V,e("DirectedEdge"),"directed"),t(V,e("UndirectedEdge"),"undirected")}),[{name:"edges",type:"mixed"},{name:"inEdges",type:"directed",direction:"in"},{name:"outEdges",type:"directed",direction:"out"},{name:"inboundEdges",type:"mixed",direction:"in"},{name:"outboundEdges",type:"mixed",direction:"out"},{name:"directedEdges",type:"directed"},{name:"undirectedEdges",type:"undirected"}].forEach(e=>{!function(e,t){let{name:r,type:i,direction:n}=t;e.prototype[r]=function(e,t){var o,d,a;if("mixed"!==i&&"mixed"!==this.type&&i!==this.type)return[];if(!arguments.length)return function(e,t){let r,i;if(0===e.size)return[];if("mixed"===t||t===e.type)return Array.from(e._edges.keys());let n=Array("undirected"===t?e.undirectedSize:e.directedSize),o="undirected"===t,d=e._edges.values(),a=0;for(;!0!==(r=d.next()).done;)(i=r.value).undirected===o&&(n[a++]=i.key);return n}(this,i);if(1==arguments.length){let t;e=""+e;let a=this._nodes.get(e);if(void 0===a)throw new b(`Graph.${r}: could not find the "${e}" node in the graph.`);return o=this.multi,d="mixed"===i?this.type:i,t=[],M(!1,o,d,n,a,function(e){t.push(e)}),t}if(2==arguments.length){let o;e=""+e,t=""+t;let d=this._nodes.get(e);if(!d)throw new b(`Graph.${r}:  could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new b(`Graph.${r}:  could not find the "${t}" target node in the graph.`);return a=this.multi,o=[],z(!1,i,a,n,d,t,function(e){o.push(e)}),o}throw new m(`Graph.${r}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)}}(V,e),function(e,t){let{name:r,type:i,direction:n}=t,o="forEach"+r[0].toUpperCase()+r.slice(1,-1);e.prototype[o]=function(e,t,r){if("mixed"===i||"mixed"===this.type||i===this.type){if(1==arguments.length)return U(!1,this,i,r=e);if(2==arguments.length){e=""+e,r=t;let d=this._nodes.get(e);if(void 0===d)throw new b(`Graph.${o}: could not find the "${e}" node in the graph.`);return M(!1,this.multi,"mixed"===i?this.type:i,n,d,r)}if(3==arguments.length){e=""+e,t=""+t;let d=this._nodes.get(e);if(!d)throw new b(`Graph.${o}:  could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new b(`Graph.${o}:  could not find the "${t}" target node in the graph.`);return z(!1,i,this.multi,n,d,t,r)}throw new m(`Graph.${o}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)}};let d="map"+r[0].toUpperCase()+r.slice(1);e.prototype[d]=function(){let e,t=Array.prototype.slice.call(arguments),r=t.pop();if(0===t.length){let n=0;"directed"!==i&&(n+=this.undirectedSize),"undirected"!==i&&(n+=this.directedSize),e=Array(n);let o=0;t.push((t,i,n,d,a,s,u)=>{e[o++]=r(t,i,n,d,a,s,u)})}else e=[],t.push((t,i,n,o,d,a,s)=>{e.push(r(t,i,n,o,d,a,s))});return this[o].apply(this,t),e};let a="filter"+r[0].toUpperCase()+r.slice(1);e.prototype[a]=function(){let e=Array.prototype.slice.call(arguments),t=e.pop(),r=[];return e.push((e,i,n,o,d,a,s)=>{t(e,i,n,o,d,a,s)&&r.push(e)}),this[o].apply(this,e),r};let s="reduce"+r[0].toUpperCase()+r.slice(1);e.prototype[s]=function(){let e,t,r=Array.prototype.slice.call(arguments);if(r.length<2||r.length>4)throw new m(`Graph.${s}: invalid number of arguments (expecting 2, 3 or 4 and got ${r.length}).`);if("function"==typeof r[r.length-1]&&"function"!=typeof r[r.length-2])throw new m(`Graph.${s}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);2===r.length?(e=r[0],t=r[1],r=[]):3===r.length?(e=r[1],t=r[2],r=[r[0]]):4===r.length&&(e=r[2],t=r[3],r=[r[0],r[1]]);let i=t;return r.push((t,r,n,o,d,a,s)=>{i=e(i,t,r,n,o,d,a,s)}),this[o].apply(this,r),i}}(V,e),function(e,t){let{name:r,type:i,direction:n}=t,o="find"+r[0].toUpperCase()+r.slice(1,-1);e.prototype[o]=function(e,t,r){if("mixed"!==i&&"mixed"!==this.type&&i!==this.type)return!1;if(1==arguments.length)return U(!0,this,i,r=e);if(2==arguments.length){e=""+e,r=t;let d=this._nodes.get(e);if(void 0===d)throw new b(`Graph.${o}: could not find the "${e}" node in the graph.`);return M(!0,this.multi,"mixed"===i?this.type:i,n,d,r)}if(3==arguments.length){e=""+e,t=""+t;let d=this._nodes.get(e);if(!d)throw new b(`Graph.${o}:  could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new b(`Graph.${o}:  could not find the "${t}" target node in the graph.`);return z(!0,i,this.multi,n,d,t,r)}throw new m(`Graph.${o}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)};let d="some"+r[0].toUpperCase()+r.slice(1,-1);e.prototype[d]=function(){let e=Array.prototype.slice.call(arguments),t=e.pop();return e.push((e,r,i,n,o,d,a)=>t(e,r,i,n,o,d,a)),!!this[o].apply(this,e)};let a="every"+r[0].toUpperCase()+r.slice(1,-1);e.prototype[a]=function(){let e=Array.prototype.slice.call(arguments),t=e.pop();return e.push((e,r,i,n,o,d,a)=>!t(e,r,i,n,o,d,a)),!this[o].apply(this,e)}}(V,e),function(e,t){let{name:r,type:i,direction:n}=t,o=r.slice(0,-1)+"Entries";e.prototype[o]=function(e,t){var r;if("mixed"!==i&&"mixed"!==this.type&&i!==this.type)return f();if(!arguments.length)return function(e,t){if(0===e.size)return f();let r="mixed"!==t&&t!==e.type,i="undirected"===t,n=e._edges.values();return{[Symbol.iterator](){return this},next(){let e,t;for(;;){if((e=n.next()).done)return e;if(t=e.value,!r||t.undirected===i)break}return{value:{edge:t.key,attributes:t.attributes,source:t.source.key,target:t.target.key,sourceAttributes:t.source.attributes,targetAttributes:t.target.attributes,undirected:t.undirected},done:!1}}}}(this,i);if(1==arguments.length){let t;e=""+e;let r=this._nodes.get(e);if(!r)throw new b(`Graph.${o}: could not find the "${e}" node in the graph.`);return t=f(),"undirected"!==i&&("out"!==n&&void 0!==r.in&&(t=g(t,N(r.in))),"in"!==n&&void 0!==r.out&&(t=g(t,N(r.out,n?void 0:r.key)))),"directed"!==i&&void 0!==r.undirected&&(t=g(t,N(r.undirected))),t}if(2==arguments.length){let d;e=""+e,t=""+t;let a=this._nodes.get(e);if(!a)throw new b(`Graph.${o}:  could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new b(`Graph.${o}:  could not find the "${t}" target node in the graph.`);return r=t,d=f(),"undirected"!==i&&(void 0!==a.in&&"out"!==n&&r in a.in&&(d=g(d,L(a.in,r))),void 0!==a.out&&"in"!==n&&r in a.out&&(n||a.key!==r)&&(d=g(d,L(a.out,r)))),"directed"!==i&&void 0!==a.undirected&&r in a.undirected&&(d=g(d,L(a.undirected,r))),d}throw new m(`Graph.${o}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)}}(V,e)}),[{name:"neighbors",type:"mixed"},{name:"inNeighbors",type:"directed",direction:"in"},{name:"outNeighbors",type:"directed",direction:"out"},{name:"inboundNeighbors",type:"mixed",direction:"in"},{name:"outboundNeighbors",type:"mixed",direction:"out"},{name:"directedNeighbors",type:"directed"},{name:"undirectedNeighbors",type:"undirected"}].forEach(e=>{!function(e,t){let{name:r,type:i,direction:n}=t;e.prototype[r]=function(e){if("mixed"!==i&&"mixed"!==this.type&&i!==this.type)return[];e=""+e;let t=this._nodes.get(e);if(void 0===t)throw new b(`Graph.${r}: could not find the "${e}" node in the graph.`);var o="mixed"===i?this.type:i;if("mixed"!==o){if("undirected"===o)return Object.keys(t.undirected);if("string"==typeof n)return Object.keys(t[n])}let d=[];return W(!1,o,n,t,function(e){d.push(e)}),d}}(V,e),function(e,t){let{name:r,type:i,direction:n}=t,o="forEach"+r[0].toUpperCase()+r.slice(1,-1);e.prototype[o]=function(e,t){if("mixed"!==i&&"mixed"!==this.type&&i!==this.type)return;e=""+e;let r=this._nodes.get(e);if(void 0===r)throw new b(`Graph.${o}: could not find the "${e}" node in the graph.`);W(!1,"mixed"===i?this.type:i,n,r,t)};let d="map"+r[0].toUpperCase()+r.slice(1);e.prototype[d]=function(e,t){let r=[];return this[o](e,(e,i)=>{r.push(t(e,i))}),r};let a="filter"+r[0].toUpperCase()+r.slice(1);e.prototype[a]=function(e,t){let r=[];return this[o](e,(e,i)=>{t(e,i)&&r.push(e)}),r};let s="reduce"+r[0].toUpperCase()+r.slice(1);e.prototype[s]=function(e,t,r){if(arguments.length<3)throw new m(`Graph.${s}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);let i=r;return this[o](e,(e,r)=>{i=t(i,e,r)}),i}}(V,e),function(e,t){let{name:r,type:i,direction:n}=t,o=r[0].toUpperCase()+r.slice(1,-1),d="find"+o;e.prototype[d]=function(e,t){if("mixed"!==i&&"mixed"!==this.type&&i!==this.type)return;e=""+e;let r=this._nodes.get(e);if(void 0===r)throw new b(`Graph.${d}: could not find the "${e}" node in the graph.`);return W(!0,"mixed"===i?this.type:i,n,r,t)},e.prototype["some"+o]=function(e,t){return!!this[d](e,t)},e.prototype["every"+o]=function(e,t){return!this[d](e,(e,r)=>!t(e,r))}}(V,e),function(e,t){let{name:r,type:i,direction:n}=t,o=r.slice(0,-1)+"Entries";e.prototype[o]=function(e){if("mixed"!==i&&"mixed"!==this.type&&i!==this.type)return f();e=""+e;let t=this._nodes.get(e);if(void 0===t)throw new b(`Graph.${o}: could not find the "${e}" node in the graph.`);var r="mixed"===i?this.type:i;if("mixed"!==r){if("undirected"===r)return O(null,t,t.undirected);if("string"==typeof n)return O(null,t,t[n])}let d=f(),a=new j;return"undirected"!==r&&("out"!==n&&(d=g(d,O(a,t,t.in))),"in"!==n&&(d=g(d,O(a,t,t.out)))),"directed"!==r&&(d=g(d,O(a,t,t.undirected))),d}}(V,e)});class H extends V{constructor(e){const t=a({type:"directed"},e);if("multi"in t&&!1!==t.multi)throw new m("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if("directed"!==t.type)throw new m('DirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}class J extends V{constructor(e){const t=a({type:"undirected"},e);if("multi"in t&&!1!==t.multi)throw new m("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if("undirected"!==t.type)throw new m('UndirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}class Q extends V{constructor(e){const t=a({multi:!0},e);if("multi"in t&&!0!==t.multi)throw new m("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");super(t)}}class X extends V{constructor(e){const t=a({type:"directed",multi:!0},e);if("multi"in t&&!0!==t.multi)throw new m("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if("directed"!==t.type)throw new m('MultiDirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}class ee extends V{constructor(e){const t=a({type:"undirected",multi:!0},e);if("multi"in t&&!0!==t.multi)throw new m("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if("undirected"!==t.type)throw new m('MultiUndirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}function et(e){e.from=function(t,r){let i=new e(a({},t.options,r));return i.import(t),i}}et(V),et(H),et(J),et(Q),et(X),et(ee),V.Graph=V,V.DirectedGraph=H,V.UndirectedGraph=J,V.MultiGraph=Q,V.MultiDirectedGraph=X,V.MultiUndirectedGraph=ee,V.InvalidArgumentsGraphError=m,V.NotFoundGraphError=b,V.UsageGraphError=w,e.i(47167);let er="".replace(/\/+$/u,"");function ei(e){return e.startsWith("/")&&er?"/"===e?er:e.startsWith(`${er}/`)?e:`${er}${e}`:e}let en={background:"#fafaf9",foreground:"#1c1917",muted:"#78716c",rule:"#e7e5e4"},eo="#3b82f6",ed="#94a3b8";function ea(e,t,r){return Math.min(r,Math.max(t,e))}function es(e){return Math.round(100*e)/100}function eu(e){let t=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);return t?{r:parseInt(t[1],16),g:parseInt(t[2],16),b:parseInt(t[3],16)}:{r:100,g:100,b:100}}function eh(e,t,r){return"#"+[e,t,r].map(e=>{let t=Math.max(0,Math.min(255,Math.round(e))).toString(16);return 1===t.length?`0${t}`:t}).join("")}function el(e,t,r){let i=eu(e),n=eu(r);return eh(n.r+(i.r-n.r)*t,n.g+(i.g-n.g)*t,n.b+(i.b-n.b)*t)}function ec(e,t){let r=eu(e);return eh(r.r+(255-r.r)*(t-1)/t,r.g+(255-r.g)*(t-1)/t,r.b+(255-r.b)*(t-1)/t)}function ep(e,t,r){if(!t.label)return;let i="string"==typeof t.label?t.label:String(t.label);if(!i)return;let n=r.labelSize;e.font=`${r.labelWeight} ${n}px ${r.labelFont}`,e.fillStyle=function(e,t){if("attribute"in t&&t.attribute){let r=e[t.attribute];if("string"==typeof r&&r.length>0)return r}return t.color??"#000"}(t,r.labelColor);let o=Math.round(t.x+t.size+3),d=Math.round(t.y+n/3);e.fillText(i,o,d)}function eg(e,t){let r=.45>function(e){let{r:t,g:r,b:i}=eu(e),n=e=>{let t=e/255;return t<=.04045?t/12.92:((t+.055)/1.055)**2.4},[o,d,a]=[n(t),n(r),n(i)];return .2126*o+.7152*d+.0722*a}(t.background),i=r?44:40,n=r?66:74,o=new Map;return e.forEach((e,t)=>{var r;let d,a,s,u,h,l,c,p,g;o.set(e.id,(r=(137.508*t+24)%360,d=ea(i,0,100)/100,s=(1-Math.abs(2*(a=ea(n,0,100)/100)-1))*d,h=s*(1-Math.abs((u=(r%360+360)%360/60)%2-1)),l=0,c=0,p=0,u>=0&&u<1?[l,c,p]=[s,h,0]:u<2?[l,c,p]=[h,s,0]:u<3?[l,c,p]=[0,s,h]:u<4?[l,c,p]=[0,h,s]:u<5?[l,c,p]=[h,0,s]:[l,c,p]=[s,0,h],eh((l+(g=a-s/2))*255,(c+g)*255,(p+g)*255)))}),o}function ef(e,t){return getComputedStyle(document.documentElement).getPropertyValue(e).trim()||t}function ey(e){return`cat:${e}`}function em(e){return e.startsWith("cat:")?{type:"category",id:e.slice(4)}:e.startsWith("post:")?{type:"post",id:e.slice(5)}:null}function eb(e){var t;return e?"category"===e.type?ey(e.id):(t=e.id,`post:${t}`):null}function ew({categories:t,posts:d,allPosts:a,draftSlugs:s}){let u="true"===(0,o.useSearchParams)().get("drafts"),h=u?a:d,l=(0,i.useMemo)(()=>new Set(s),[s]),[c,p]=(0,i.useState)(null),[g,f]=(0,i.useState)(null),y=g??c,[m,b]=(0,i.useState)(null),[w,x]=(0,i.useState)(!1),[$,k]=(0,i.useState)(!1),v=(0,i.useRef)(null),G=(0,i.useRef)(null),_=(0,i.useRef)(null),E=(0,i.useRef)(null),A=(0,i.useRef)(null),S=(0,i.useRef)(null),N=(0,i.useRef)(null),D=(0,i.useRef)(en),C=(0,i.useRef)(new Map),L=(0,i.useRef)({nodes:null,edges:null}),U=(0,i.useCallback)(e=>{"Escape"===e.key&&(document.exitFullscreen().catch(()=>{}),x(!1))},[]);(0,i.useEffect)(()=>(w?(document.addEventListener("keydown",U),document.body.style.overflow="hidden"):document.body.style.overflow="",()=>{document.removeEventListener("keydown",U),document.body.style.overflow=""}),[w,U]),(0,i.useEffect)(()=>{let e=()=>{x(document.fullscreenElement===v.current),_.current?.refresh()};return document.addEventListener("fullscreenchange",e),()=>{document.removeEventListener("fullscreenchange",e)}},[]);let M=(0,i.useMemo)(()=>new Map(h.map(e=>[e.slug,e])),[h]),z=(0,i.useMemo)(()=>new Map(t.map(e=>[e.id,e.label])),[t]),j=(0,i.useMemo)(()=>m?M.get(m)??null:null,[m,M]),I=(0,i.useMemo)(()=>eg(t,D.current),[t]),{graph:W}=(0,i.useMemo)(()=>{var e;let r,i;return e=D.current,r=new V,i=new Map,t.forEach((n,o)=>{let d,a={x:es(9.5*Math.cos(d=-Math.PI/2+o/Math.max(t.length,1)*Math.PI*2)),y:es(9.5*Math.sin(d))};i.set(n.id,a);let s=ey(n.id);r.addNode(s,{x:a.x,y:a.y,size:10.5,color:I.get(n.id)??e.foreground,label:n.label,type:"circle",nodeType:"category",categoryId:n.id})}),h.forEach(t=>{var n,o;let d=t.categories.map(e=>i.get(e)).filter(Boolean),a=d.length>0?d.reduce((e,t)=>e+t.x,0)/d.length:0,s=d.length>0?d.reduce((e,t)=>e+t.y,0)/d.length:0,u=function(e){let t=0;for(let r of e)t=(t<<5)-t+r.charCodeAt(0)|0;return Math.abs(t)}(t.slug),h=u%360*Math.PI/180,c=.8+u%40/12,p=l.has(t.slug),g=(n=t.slug,`post:${n}`);r.addNode(g,{x:a+Math.cos(h)*c,y:s+Math.sin(h)*c,size:4.2+.7*ea(Number.isFinite(o=t.size)?Math.round(o):2,1,5),color:p?ed:eo,label:`[${t.title}]`,type:"image",nodeType:"post",slug:t.slug,categoryIds:t.categories,summary:t.summary,image:t.image,isDraft:p}),t.categories.filter(e=>i.has(e)).forEach(i=>{let n=ey(i),o=`${g}->${n}`;if(r.hasEdge(o))return;let d=I.get(i)??e.rule;r.addEdgeWithKey(o,g,n,{size:1,color:p?el(d,.58,e.background):d,postSlug:t.slug,categoryId:i,isDraft:p,type:"curved",curvature:.12+u%7*.01})})}),{graph:r}},[h,t,l,I]),O=(0,i.useRef)(W);(0,i.useEffect)(()=>{C.current=I},[I]);let P=(0,i.useCallback)(()=>{let e=E.current,r=_.current,i=D.current,n=eg(t,i);C.current=n,e&&(e.forEachNode((t,r)=>{"category"===r.nodeType&&r.categoryId?e.mergeNodeAttributes(t,{color:n.get(r.categoryId)??i.foreground}):"post"===r.nodeType&&e.mergeNodeAttributes(t,{color:r.isDraft?ed:eo})}),e.forEachEdge((t,r)=>{let o=n.get(r.categoryId)??i.rule;e.mergeEdgeAttributes(t,{color:r.isDraft?el(o,.58,i.background):o})}),r&&(r.setSetting("labelColor",{color:i.foreground}),r.refresh()))},[t]),R=(0,i.useCallback)(async()=>{if(A.current)return A.current;let[t,r,i,n,o,d]=await Promise.all([e.A(64355),e.A(64490),e.A(61943),e.A(38587),e.A(61751),e.A(70898)]),a={SigmaCtor:t.default,EdgeCurveProgram:r.default,NodeImageProgram:i.NodeImageProgram,ForceAtlas2LayoutCtor:n.default,forceAtlas2:o.default,noverlap:d.default};return A.current=a,a},[]);(0,i.useEffect)(()=>{let e=()=>{D.current={background:ef("--background",en.background),foreground:ef("--foreground",en.foreground),muted:ef("--muted",en.muted),rule:ef("--rule",en.rule)},P()};e();let t=new MutationObserver(e);return t.observe(document.documentElement,{attributes:!0,attributeFilter:["data-theme","style"]}),()=>t.disconnect()},[P]);let T=(0,i.useCallback)(()=>{let e=E.current,t=S.current;if(!e||!t||!e.hasNode(t)){L.current={nodes:null,edges:null};return}let r=new Set,i=new Set;if(r.add(t),"post"===e.getNodeAttributes(t).nodeType)e.forEachEdge(t,(e,t,n,o)=>{i.add(e),r.add(n),r.add(o)});else{let n=[];e.forEachNeighbor(t,t=>{"post"===e.getNodeAttributes(t).nodeType&&(n.push(t),r.add(t))}),n.forEach(t=>{e.forEachEdge(t,(e,t,n,o)=>{i.add(e),r.add(n),r.add(o)})})}L.current={nodes:r,edges:i}},[]),K=(0,i.useCallback)(async(e,t)=>{if(0===e.order)return;let r=t?.engine??await R(),i=t?.showIndicator??!0;i&&k(!0);let n={...r.forceAtlas2.inferSettings(e),gravity:.06,scalingRatio:5.5,slowDown:e.order>300?1.9:1.4,barnesHutOptimize:e.order>150,strongGravityMode:!1,adjustSizes:!0,outboundAttractionDistribution:!0};r.forceAtlas2.assign(e,{iterations:e.order>180?220:160,settings:n}),r.noverlap.assign(e,{maxIterations:24,settings:{ratio:1.02,margin:2,expansion:1.02}}),function(e,t){if(e.order<2)return;let r=1/0,i=-1/0,n=1/0,o=-1/0;e.forEachNode((e,t)=>{r=Math.min(r,t.x),i=Math.max(i,t.x),n=Math.min(n,t.y),o=Math.max(o,t.y)});let d=Math.max(i-r,o-n);if(!Number.isFinite(d)||d<=0||d<=t.maxSpan)return;let a=(r+i)/2,s=(n+o)/2,u=t.maxSpan/d;e.forEachNode((t,r)=>{e.mergeNodeAttributes(t,{x:a+(r.x-a)*u,y:s+(r.y-s)*u})})}(e,{maxSpan:16}),r.noverlap.assign(e,{maxIterations:10,settings:{ratio:1.01,margin:1.2,expansion:1.01}}),_.current?.refresh(),i&&k(!1)},[R]);(0,i.useEffect)(()=>{if(!G.current)return;let e=!1;return(async()=>{let t=await R();if(e||!G.current)return;let r=new t.SigmaCtor(new V,G.current,{renderLabels:!0,defaultDrawNodeLabel:ep,labelFont:"var(--font-inter), Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, sans-serif",labelSize:12,labelWeight:"600",labelColor:{color:D.current.foreground},labelDensity:.15,labelGridCellSize:70,defaultNodeColor:eo,defaultEdgeColor:en.rule,nodeProgramClasses:{image:t.NodeImageProgram},defaultEdgeType:"curved",edgeProgramClasses:{curved:t.EdgeCurveProgram},zIndex:!0,hideEdgesOnMove:!0,minCameraRatio:.04,maxCameraRatio:4,labelRenderedSizeThreshold:1.35,nodeReducer:(e,t)=>{let r={...t},i=D.current,n=C.current,o=S.current,d=N.current,a=L.current.nodes,s=!a||a.has(e),u=o===e,h=d===e;return("category"===t.nodeType&&t.categoryId&&(r.color=n.get(t.categoryId)??i.foreground),s)?(u||h)&&(r.color="category"===t.nodeType?ec(r.color,1.2):ec(t.color,1.4),r.size=1.3*(t.size||4),r.zIndex=2):(r.color=el(t.color,.18,i.background),r.size=Math.max(1.6,.7*(t.size||4)),r.label="",r.zIndex=0),r},edgeReducer:(e,t)=>{let r={...t},i=D.current,n=L.current.edges,o=S.current,d=!n||n.has(e),a=E.current,s=a?a.extremities(e):null,u=!!o&&!!s&&(s[0]===o||s[1]===o);return d?u?(r.color=ec(t.color,1.35),r.size=Math.max(1.8,1.8*(t.size||1)),r.zIndex=2):r.size=Math.max(.7,t.size||1):(r.color=el(t.color,.12,i.background),r.size=.25,r.zIndex=0),r}});_.current=r;let i=O.current;E.current=i,await K(i,{engine:t,showIndicator:!1}),r.setGraph(i),P(),r.getCamera().animatedReset({duration:280}),r.on("enterNode",e=>{let t=e?.node;if(!t)return;let r=E.current;if(!r||!r.hasNode(t))return;let i=r.getNodeAttributes(t);p(em(t)),"post"===i.nodeType&&i.slug?b(i.slug):b(null),G.current&&(G.current.style.cursor="pointer")}),r.on("leaveNode",()=>{p(null),b(null),G.current&&(G.current.style.cursor="grab")}),r.on("clickNode",e=>{let t=e?.node;if(!t)return;let r=E.current;if(!r||!r.hasNode(t))return;let i=r.getNodeAttributes(t),n=em(t);if(n){if("post"===i.nodeType&&i.slug){window.location.href=ei(`/blog/${i.slug}`);return}f(e=>e&&e.type===n.type&&e.id===n.id?null:n)}}),r.on("clickStage",()=>{f(null),p(null),b(null)}),G.current&&(G.current.style.cursor="grab")})(),()=>{e=!0,k(!1),_.current?.kill(),_.current=null,E.current=null}},[P,R,K]),(0,i.useEffect)(()=>{let e=!1;return(O.current=W,_.current)?((async()=>{await K(W,{showIndicator:!1}),!e&&_.current&&(E.current=W,_.current.setGraph(W),P(),_.current.getCamera().animatedReset({duration:280}))})(),()=>{e=!0}):()=>{}},[P,K,W]),(0,i.useEffect)(()=>{S.current=eb(y),N.current=eb(g),T(),_.current?.refresh()},[y,g,T]);let F=(0,i.useCallback)(()=>{_.current?.getCamera().animatedZoom({duration:200})},[]),B=(0,i.useCallback)(()=>{_.current?.getCamera().animatedUnzoom({duration:200})},[]),Y=(0,i.useCallback)(()=>{_.current?.getCamera().animatedReset({duration:260}),f(null)},[]),Z=(0,i.useCallback)(()=>{let e=E.current;e&&K(e,{showIndicator:!0})},[K]),q=(0,i.useCallback)(async()=>{if(v.current){if(document.fullscreenElement===v.current)return void await document.exitFullscreen();await v.current.requestFullscreen()}},[]),H=j?(0,r.jsxs)("div",{className:"pointer-events-none absolute left-3 top-3 z-10 w-64 rounded border border-rule bg-background p-3 shadow-sm",children:[j.image?(0,r.jsx)("div",{className:"relative mb-2 h-32 w-full overflow-hidden rounded",children:(0,r.jsx)(n.default,{src:ei(j.image),alt:"",fill:!0,unoptimized:!0,className:"object-cover",sizes:"256px"})}):null,(0,r.jsxs)("p",{className:"text-sm font-medium leading-snug text-foreground",children:[j.title,l.has(j.slug)?(0,r.jsx)("span",{className:"ml-1.5 inline-block rounded bg-rule px-1.5 py-0.5 text-[10px] uppercase text-muted",children:"draft"}):null]}),j.summary?(0,r.jsx)("p",{className:"mt-1 line-clamp-3 text-xs leading-relaxed text-muted",children:j.summary}):null,j.categories.length>0?(0,r.jsx)("div",{className:"mt-2 flex flex-wrap gap-1",children:j.categories.map(e=>(0,r.jsx)("span",{className:"rounded bg-rule px-1.5 py-0.5 text-[10px] text-muted",children:z.get(e)??e},e))}):null]}):null;return(0,r.jsxs)("div",{className:"relative left-1/2 right-1/2 -ml-[50vw] w-[100vw] space-y-4 sm:-ml-[40vw] sm:w-[80vw]",children:[u?(0,r.jsx)("p",{className:"border border-rule px-4 py-2 text-sm text-muted",children:"Draft preview mode  draft nodes are rendered in muted color."}):null,(0,r.jsxs)("div",{ref:v,className:["relative overflow-hidden rounded border border-rule bg-background",w?"h-screen w-screen rounded-none border-none":"h-[360px] sm:h-[560px]"].join(" "),children:[H,(0,r.jsx)("div",{ref:G,className:"h-full w-full cursor-grab active:cursor-grabbing",role:"img","aria-label":"Productivity graph connecting categories and active posts"}),$?(0,r.jsx)("div",{className:"absolute bottom-3 left-1/2 -translate-x-1/2 rounded-full border border-rule bg-background/95 px-3 py-1 text-xs text-muted",children:"Optimizing layout..."}):null]}),(0,r.jsxs)("div",{className:"flex items-center justify-between",children:[(0,r.jsx)("p",{className:"text-sm text-muted",children:"Drag to pan and scroll to zoom. Click a category to pin focus; click a post to open it."}),(0,r.jsxs)("div",{className:"flex shrink-0 gap-4",children:[(0,r.jsx)("button",{type:"button",onClick:B,className:"text-sm text-muted hover:text-foreground",children:"Zoom out"}),(0,r.jsx)("button",{type:"button",onClick:F,className:"text-sm text-muted hover:text-foreground",children:"Zoom in"}),(0,r.jsx)("button",{type:"button",onClick:Y,className:"text-sm text-muted hover:text-foreground",children:"Reset view"}),(0,r.jsx)("button",{type:"button",onClick:Z,className:"text-sm text-muted hover:text-foreground",children:"Rebalance layout"}),(0,r.jsx)("button",{type:"button",onClick:q,className:"text-sm text-muted hover:text-foreground",children:w?"Exit fullscreen":"Fullscreen"})]})]})]})}e.s(["ProductivityGraph",()=>ew],85169)}]);